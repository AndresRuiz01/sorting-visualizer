{"ast":null,"code":"// // First write the swap function, which is just a helper function to swap values of the array.\n// function swap(array, i, j) {\n//     var temp = array[i];\n//     array[i] = array[j];\n//     array[j] = temp;\n// }\n// function quicksortLomuto(array, left, right) {\n//     var _;\n//     var animationsQuickSort = []\n//     var animationsLeft = [];\n//     var animationsRight = [];\n//     var animationsPartition = [];\n//     var pivot;\n//     left = left || 0;\n//     right = right || array.length - 1;\n//     [pivot, animationsPartition]  = partitionLomuto(array, left, right);\n//     if (left < pivot - 1) {\n//         [_, animationsLeft] = quicksortLomuto(array, left, pivot - 1);\n//     }\n//     if (right > pivot) {\n//         [_, animationsRight] = quicksortLomuto(array, pivot - 1, right)\n//     }\n//     animationsQuickSort = [...animationsPartition, ...animationsRight, ...animationsLeft];\n//     return [array, animationsQuickSort];\n// }\n// function partitionLomuto(array, left, right) {\n//     // Lomuto algorithm always uses the last element, array[right], for the pivot.\n//     var animations = [];\n//     var pivot = right;\n//     var i = left;\n//     /*The logic under Lomuto is, we start from the leftmost element and keep track of index of smaller (or equal to) elements as j. While traversing, if we find a smaller element, we swap current element with arr[j]. Otherwise we ignore current element.*/\n//     for (var j = left; j < right; j++) {\n//         if (array[j] <= array[pivot]) {\n//             animations.push([\"swap\", i, j]);\n//             swap(array, i, j);\n//             i++\n//         }\n//     }\n//     animations.push([\"swap\", i, j]);\n//     swap(array, i, j);\n//     return [i, animations];\n// }\n// First write the swap function, which is just a helper function to swap values of the array.\nfunction swap(array, i, j) {\n  var temp = array[i];\n  array[i] = array[j];\n  array[j] = temp;\n}\n\nfunction quicksortLomuto(array, left, right) {\n  // left-pointer would be the index of the first element which is 0 and right-pointer would be the index of the last element which would be (length -1).\n  var pivot = partitionLomuto(array, left, right);\n\n  if (left < pivot - 1) {\n    quicksortLomuto(array, left, pivot - 1);\n  }\n\n  if (right > pivot) {\n    quicksortLomuto(array, pivot - 1, right);\n  }\n\n  return array;\n}\n\nfunction partitionLomuto(array, left, right) {\n  // Lomuto algorithm always uses the last element, array[right], for the pivot.\n  var pivot = right;\n  var i = left;\n  /*The logic under Lomuto is, we start from the leftmost element and keep track of index of smaller (or equal to) elements as j. While traversing, if we find a smaller element, we swap current element with arr[j]. Otherwise we ignore current element.*/\n\n  for (var j = left; j < right; j++) {\n    if (array[j] <= array[pivot]) {\n      swap(array, i, j);\n      i++;\n    }\n  }\n\n  swap(array, i, j);\n  return i;\n}\n\nexport default quicksortLomuto;","map":{"version":3,"sources":["/Users/andres/Desktop/personal_projects/learning-react/sorting-visualizer/src/sorting_algorithms/quickSortLomunto.js"],"names":["swap","array","i","j","temp","quicksortLomuto","left","right","pivot","partitionLomuto"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA,SAASA,IAAT,CAAcC,KAAd,EAAqBC,CAArB,EAAwBC,CAAxB,EAA2B;AACvB,MAAIC,IAAI,GAAGH,KAAK,CAACC,CAAD,CAAhB;AACAD,EAAAA,KAAK,CAACC,CAAD,CAAL,GAAWD,KAAK,CAACE,CAAD,CAAhB;AACAF,EAAAA,KAAK,CAACE,CAAD,CAAL,GAAWC,IAAX;AACH;;AAED,SAASC,eAAT,CAAyBJ,KAAzB,EAAgCK,IAAhC,EAAsCC,KAAtC,EAA6C;AACzC;AAGA,MAAIC,KAAK,GAAGC,eAAe,CAACR,KAAD,EAAQK,IAAR,EAAcC,KAAd,CAA3B;;AAEA,MAAID,IAAI,GAAGE,KAAK,GAAG,CAAnB,EAAsB;AAClBH,IAAAA,eAAe,CAACJ,KAAD,EAAQK,IAAR,EAAcE,KAAK,GAAG,CAAtB,CAAf;AACH;;AAED,MAAID,KAAK,GAAGC,KAAZ,EAAmB;AACfH,IAAAA,eAAe,CAACJ,KAAD,EAAQO,KAAK,GAAG,CAAhB,EAAmBD,KAAnB,CAAf;AACH;;AAED,SAAON,KAAP;AACH;;AAED,SAASQ,eAAT,CAAyBR,KAAzB,EAAgCK,IAAhC,EAAsCC,KAAtC,EAA6C;AACzC;AACA,MAAIC,KAAK,GAAGD,KAAZ;AACA,MAAIL,CAAC,GAAGI,IAAR;AAEA;;AACA,OAAK,IAAIH,CAAC,GAAGG,IAAb,EAAmBH,CAAC,GAAGI,KAAvB,EAA8BJ,CAAC,EAA/B,EAAmC;AAC/B,QAAIF,KAAK,CAACE,CAAD,CAAL,IAAYF,KAAK,CAACO,KAAD,CAArB,EAA8B;AAC1BR,MAAAA,IAAI,CAACC,KAAD,EAAQC,CAAR,EAAWC,CAAX,CAAJ;AACAD,MAAAA,CAAC;AACJ;AACJ;;AACDF,EAAAA,IAAI,CAACC,KAAD,EAAQC,CAAR,EAAWC,CAAX,CAAJ;AACA,SAAOD,CAAP;AACH;;AAGD,eAAeG,eAAf","sourcesContent":["\n// // First write the swap function, which is just a helper function to swap values of the array.\n// function swap(array, i, j) {\n//     var temp = array[i];\n//     array[i] = array[j];\n//     array[j] = temp;\n// }\n\n// function quicksortLomuto(array, left, right) {\n//     var _;\n//     var animationsQuickSort = []\n//     var animationsLeft = [];\n//     var animationsRight = [];\n//     var animationsPartition = [];\n//     var pivot;\n\n//     left = left || 0;\n//     right = right || array.length - 1;\n\n//     [pivot, animationsPartition]  = partitionLomuto(array, left, right);\n\n//     if (left < pivot - 1) {\n//         [_, animationsLeft] = quicksortLomuto(array, left, pivot - 1);\n//     }\n\n//     if (right > pivot) {\n//         [_, animationsRight] = quicksortLomuto(array, pivot - 1, right)\n//     }\n\n//     animationsQuickSort = [...animationsPartition, ...animationsRight, ...animationsLeft];\n\n//     return [array, animationsQuickSort];\n// }\n\n// function partitionLomuto(array, left, right) {\n//     // Lomuto algorithm always uses the last element, array[right], for the pivot.\n//     var animations = [];\n//     var pivot = right;\n//     var i = left;\n\n//     /*The logic under Lomuto is, we start from the leftmost element and keep track of index of smaller (or equal to) elements as j. While traversing, if we find a smaller element, we swap current element with arr[j]. Otherwise we ignore current element.*/\n//     for (var j = left; j < right; j++) {\n//         if (array[j] <= array[pivot]) {\n//             animations.push([\"swap\", i, j]);\n//             swap(array, i, j);\n//             i++\n//         }\n//     }\n//     animations.push([\"swap\", i, j]);\n//     swap(array, i, j);\n//     return [i, animations];\n// }\n\n// First write the swap function, which is just a helper function to swap values of the array.\nfunction swap(array, i, j) {\n    var temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n}\n\nfunction quicksortLomuto(array, left, right) {\n    // left-pointer would be the index of the first element which is 0 and right-pointer would be the index of the last element which would be (length -1).\n\n\n    var pivot = partitionLomuto(array, left, right);\n\n    if (left < pivot - 1) {\n        quicksortLomuto(array, left, pivot - 1);\n    }\n\n    if (right > pivot) {\n        quicksortLomuto(array, pivot - 1, right)\n    }\n\n    return array;\n}\n\nfunction partitionLomuto(array, left, right) {\n    // Lomuto algorithm always uses the last element, array[right], for the pivot.\n    var pivot = right;\n    var i = left;\n\n    /*The logic under Lomuto is, we start from the leftmost element and keep track of index of smaller (or equal to) elements as j. While traversing, if we find a smaller element, we swap current element with arr[j]. Otherwise we ignore current element.*/\n    for (var j = left; j < right; j++) {\n        if (array[j] <= array[pivot]) {\n            swap(array, i, j);\n            i++\n        }\n    }\n    swap(array, i, j);\n    return i;\n}\n\n\nexport default quicksortLomuto;"]},"metadata":{},"sourceType":"module"}