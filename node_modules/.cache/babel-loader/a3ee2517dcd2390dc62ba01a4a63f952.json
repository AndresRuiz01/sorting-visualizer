{"ast":null,"code":"function swap(items, leftIndex, rightIndex) {\n  var temp = items[leftIndex];\n  items[leftIndex] = items[rightIndex];\n  items[rightIndex] = temp;\n}\n\nfunction partition(items, left, right) {\n  var animations = [];\n  var pivot = items[Math.floor((right + left) / 2)].props.value,\n      //middle element\n  i = left,\n      //left pointer\n  j = right; //right pointer\n\n  while (i <= j) {\n    while (items[i].props.value < pivot) {\n      i++;\n    }\n\n    while (items[j].props.value > pivot) {\n      j--;\n    }\n\n    if (i <= j) {\n      swap(items, i, j); //sawpping two elements\n\n      animations.push([\"swap\", i, j]);\n      i++;\n      j--;\n    }\n  }\n\n  console.log(animations);\n  return [i, animations];\n}\n\nfunction quickSort(items, left, right) {\n  var index;\n\n  var _;\n\n  var animationsQuickSort = [];\n  var animationsLeft = [];\n  var animationsRight = [];\n  var animationsPartition = [];\n\n  if (items.length > 1) {\n    [index, animationsPartition] = partition(items, left, right); //index returned from partition\n\n    if (left < index - 1) {\n      //more elements on the left side of the pivot\n      [_, animationsLeft] = quickSort(items, left, index - 1);\n    }\n\n    if (index < right) {\n      //more elements on the right side of the pivot\n      [_, animationsRight] = quickSort(items, index, right);\n    }\n  }\n\n  animationsQuickSort = [...animationsPartition, ...animationsRight, ...animationsLeft];\n  return [items, animationsQuickSort];\n}\n\nexport default quickSort;\n\nfunction quicksortHoare(array, left, right) {\n  var _;\n\n  var animationsQuickSort = [];\n  var animationsLeft = [];\n  var animationsRight = [];\n  var animationsPartition = [];\n  left = left || 0;\n  right = right || array.length - 1;\n  var [pivot, animationsPartition] = partitionHoare(array, left, right);\n\n  if (left < pivot - 1) {\n    quicksortHoare(array, left, pivot - 1);\n  }\n\n  if (right > pivot) {\n    quicksortHoare(array, pivot, right);\n  }\n\n  animationsQuickSort = [...animationsPartition, ...animationsRight, ...animationsLeft];\n  return array;\n}\n/* Two indices that start at the ends of the array being partitioned, then move toward each other, until they detect an inversion: a pair of elements, one greater than the pivot, one smaller, that are in the wrong order relative to each other. The inverted elements are then swapped. \nHere the numerical values of left and right is continually getting updated with each inner while loop. But only if the while loop condition gets satisfied. That is, when the while loop condition is unsatisfied, e.g. for the first inner while loop, when array[left] > array[pivot] which means we have found a misplaced pair. \nThat is, although the left <= right (which is being made sure by the outer while loop) the actual elements are not sorted. Meaning a left side element is larger in value than the right side element. So, the code execution then jumps out of the inner while loop and goes right in to execute the swap function.\n*/\n\n\nfunction partitionHoare(array, left, right) {\n  var pivot = Math.floor((left + right) / 2);\n\n  while (left < right) {\n    while (array[left] < array[pivot]) {\n      left++;\n    }\n\n    while (array[right] > array[pivot]) {\n      right--;\n    }\n\n    if (left <= right) {\n      swap(array, left, right);\n      left++;\n      right--;\n    }\n  }\n\n  return left;\n}","map":{"version":3,"sources":["/Users/andres/Desktop/personal_projects/learning-react/sorting-visualizer/src/sorting_algorithms/quick_sort.js"],"names":["swap","items","leftIndex","rightIndex","temp","partition","left","right","animations","pivot","Math","floor","props","value","i","j","push","console","log","quickSort","index","_","animationsQuickSort","animationsLeft","animationsRight","animationsPartition","length","quicksortHoare","array","partitionHoare"],"mappings":"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","sourcesContent":["function swap(items, leftIndex, rightIndex){\n    var temp = items[leftIndex];\n    items[leftIndex] = items[rightIndex];\n    items[rightIndex] = temp;\n}\nfunction partition(items, left, right) {\n    var animations = [];\n    var pivot = items[Math.floor((right + left) / 2)].props.value, //middle element\n    i = left, //left pointer\n    j = right; //right pointer\n    while (i <= j) {\n        while (items[i].props.value < pivot) {\n            i++;\n        }\n        while (items[j].props.value > pivot) {\n            j--;\n        }\n        if (i <= j) {\n            swap(items, i, j); //sawpping two elements\n            animations.push([\"swap\", i, j]);\n            i++;\n            j--;\n        }\n    }\n    console.log(animations);\n    return [i, animations];\n}\n\nfunction quickSort(items, left, right) {\n    var index;\n    var _;\n    var animationsQuickSort = []\n    var animationsLeft = [];\n    var animationsRight = [];\n    var animationsPartition = [];\n    if (items.length > 1) {\n        [index, animationsPartition] = partition(items, left, right); //index returned from partition\n        if (left < index - 1) { //more elements on the left side of the pivot\n            [_, animationsLeft] = quickSort(items, left, index - 1);\n        }\n        if (index < right) { //more elements on the right side of the pivot\n            [_, animationsRight] = quickSort(items, index, right);\n        }\n    }\n    animationsQuickSort = [...animationsPartition, ...animationsRight, ...animationsLeft];\n\n    return [items, animationsQuickSort];\n}\n\nexport default quickSort;\n\nfunction quicksortHoare(array, left, right) {\n    var _;\n    var animationsQuickSort = []\n    var animationsLeft = [];\n    var animationsRight = [];\n    var animationsPartition = [];\n\n    left = left || 0;\n    right = right || array.length - 1;\n\n    var [pivot, animationsPartition] = partitionHoare(array, left, right);\n\n    if (left < pivot - 1) {\n        quicksortHoare(array, left, pivot - 1);\n    }\n\n    if (right > pivot) {\n        quicksortHoare(array, pivot, right)\n    }\n\n    animationsQuickSort = [...animationsPartition, ...animationsRight, ...animationsLeft];\n\n    return array;\n\n}\n\n/* Two indices that start at the ends of the array being partitioned, then move toward each other, until they detect an inversion: a pair of elements, one greater than the pivot, one smaller, that are in the wrong order relative to each other. The inverted elements are then swapped. \nHere the numerical values of left and right is continually getting updated with each inner while loop. But only if the while loop condition gets satisfied. That is, when the while loop condition is unsatisfied, e.g. for the first inner while loop, when array[left] > array[pivot] which means we have found a misplaced pair. \nThat is, although the left <= right (which is being made sure by the outer while loop) the actual elements are not sorted. Meaning a left side element is larger in value than the right side element. So, the code execution then jumps out of the inner while loop and goes right in to execute the swap function.\n*/\nfunction partitionHoare(array, left, right) {\n    var pivot = Math.floor((left + right) / 2);\n\n    while (left < right) {\n        while (array[left] < array[pivot]) {\n            left++\n        }\n        while (array[right] > array[pivot]) {\n            right--\n        }\n\n        if (left <= right) {\n            swap(array, left, right);\n            left++;\n            right--;\n        }\n    }\n    return left;\n}"]},"metadata":{},"sourceType":"module"}