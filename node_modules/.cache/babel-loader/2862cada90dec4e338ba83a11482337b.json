{"ast":null,"code":"// // First write the swap function, which is just a helper function to swap values of the array.\n// function swap(array, i, j) {\n//     var temp = array[i];\n//     array[i] = array[j];\n//     array[j] = temp;\n// }\n// function quicksortLomuto(array, left, right) {\n//     var _;\n//     var animationsQuickSort = []\n//     var animationsLeft = [];\n//     var animationsRight = [];\n//     var animationsPartition = [];\n//     var pivot;\n//     left = left || 0;\n//     right = right || array.length - 1;\n//     [pivot, animationsPartition]  = partitionLomuto(array, left, right);\n//     if (left < pivot - 1) {\n//         [_, animationsLeft] = quicksortLomuto(array, left, pivot - 1);\n//     }\n//     if (right > pivot) {\n//         [_, animationsRight] = quicksortLomuto(array, pivot - 1, right)\n//     }\n//     animationsQuickSort = [...animationsPartition, ...animationsRight, ...animationsLeft];\n//     return [array, animationsQuickSort];\n// }\n// function partitionLomuto(array, left, right) {\n//     // Lomuto algorithm always uses the last element, array[right], for the pivot.\n//     var animations = [];\n//     var pivot = right;\n//     var i = left;\n//     /*The logic under Lomuto is, we start from the leftmost element and keep track of index of smaller (or equal to) elements as j. While traversing, if we find a smaller element, we swap current element with arr[j]. Otherwise we ignore current element.*/\n//     for (var j = left; j < right; j++) {\n//         if (array[j] <= array[pivot]) {\n//             animations.push([\"swap\", i, j]);\n//             swap(array, i, j);\n//             i++\n//         }\n//     }\n//     animations.push([\"swap\", i, j]);\n//     swap(array, i, j);\n//     return [i, animations];\n// }\n// JavaScript implementation QuickSort\n// using Lomuto's partition Scheme\nfunction Swap(array, position1, position2) {\n  // Swaps elements in an array\n  // Copy the first position's element\n  let temp = array[position1]; // Assign to the second element\n\n  array[position1] = array[position2]; // Assign to the first element\n\n  array[position2] = temp;\n}\n/* This function takes last element as\npivot, places the pivot element at its\ncorrect position in sorted array, and\nplaces all smaller (smaller than pivot)\nto left of pivot and all greater elements\nto right of pivot */\n\n\n_c = Swap;\n\nfunction partition(arr, low, high) {\n  let pivot = arr[high]; // Index of smaller element\n\n  let i = low - 1;\n\n  for (let j = low; j <= high - 1; j++) {\n    // If current element is smaller\n    // than or equal to pivot\n    if (arr[j] <= pivot) {\n      i++; // increment index of\n      // smaller element\n\n      Swap(arr, i, j);\n    }\n  }\n\n  Swap(arr, i + 1, high);\n  return i + 1;\n}\n/* The main function that\n   implements QuickSort\narr[] --> Array to be sorted,\nlow --> Starting index,\nhigh --> Ending index */\n\n\nfunction quicksortLomuto(arr, low, high) {\n  if (low < high) {\n    /* pi is partitioning index,\n    arr[p] is now at right place */\n    let pi = partition(arr, low, high); // Separately sort elements before\n    // partition and after partition\n\n    quicksortLomuto(arr, low, pi - 1);\n    quicksortLomuto(arr, pi + 1, high);\n    return arr;\n  }\n}\n\nexport default quicksortLomuto;\n\nvar _c;\n\n$RefreshReg$(_c, \"Swap\");","map":{"version":3,"sources":["/Users/andres/Desktop/personal_projects/learning-react/sorting-visualizer/src/sorting_algorithms/quickSortLomunto.js"],"names":["Swap","array","position1","position2","temp","partition","arr","low","high","pivot","i","j","quicksortLomuto","pi"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA,SAASA,IAAT,CAAcC,KAAd,EAAqBC,SAArB,EAAgCC,SAAhC,EACA;AACI;AAEA;AACA,MAAIC,IAAI,GAAGH,KAAK,CAACC,SAAD,CAAhB,CAJJ,CAMI;;AACAD,EAAAA,KAAK,CAACC,SAAD,CAAL,GAAmBD,KAAK,CAACE,SAAD,CAAxB,CAPJ,CASI;;AACAF,EAAAA,KAAK,CAACE,SAAD,CAAL,GAAmBC,IAAnB;AACH;AAED;AACA;AACA;AACA;AACA;AACA;;;KAnBSJ,I;;AAoBT,SAASK,SAAT,CAAmBC,GAAnB,EAAwBC,GAAxB,EAA6BC,IAA7B,EACA;AACI,MAAIC,KAAK,GAAGH,GAAG,CAACE,IAAD,CAAf,CADJ,CAGI;;AACA,MAAIE,CAAC,GAAIH,GAAG,GAAG,CAAf;;AAEA,OAAK,IAAII,CAAC,GAAGJ,GAAb,EAAkBI,CAAC,IAAIH,IAAI,GAAE,CAA7B,EAAgCG,CAAC,EAAjC,EACA;AACI;AACA;AACA,QAAIL,GAAG,CAACK,CAAD,CAAH,IAAUF,KAAd,EACA;AACIC,MAAAA,CAAC,GADL,CACS;AACA;;AACLV,MAAAA,IAAI,CAACM,GAAD,EAAMI,CAAN,EAASC,CAAT,CAAJ;AACH;AACJ;;AACDX,EAAAA,IAAI,CAACM,GAAD,EAAMI,CAAC,GAAG,CAAV,EAAaF,IAAb,CAAJ;AACA,SAAQE,CAAC,GAAG,CAAZ;AACH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASE,eAAT,CAAyBN,GAAzB,EAA8BC,GAA9B,EAAmCC,IAAnC,EACA;AACI,MAAID,GAAG,GAAGC,IAAV,EACA;AACI;AACR;AACQ,QAAIK,EAAE,GAAGR,SAAS,CAACC,GAAD,EAAMC,GAAN,EAAWC,IAAX,CAAlB,CAHJ,CAKI;AACA;;AACAI,IAAAA,eAAe,CAACN,GAAD,EAAMC,GAAN,EAAWM,EAAE,GAAG,CAAhB,CAAf;AACAD,IAAAA,eAAe,CAACN,GAAD,EAAMO,EAAE,GAAG,CAAX,EAAcL,IAAd,CAAf;AACA,WAAOF,GAAP;AACH;AACJ;;AAED,eAAeM,eAAf","sourcesContent":["\n// // First write the swap function, which is just a helper function to swap values of the array.\n// function swap(array, i, j) {\n//     var temp = array[i];\n//     array[i] = array[j];\n//     array[j] = temp;\n// }\n\n// function quicksortLomuto(array, left, right) {\n//     var _;\n//     var animationsQuickSort = []\n//     var animationsLeft = [];\n//     var animationsRight = [];\n//     var animationsPartition = [];\n//     var pivot;\n\n//     left = left || 0;\n//     right = right || array.length - 1;\n\n//     [pivot, animationsPartition]  = partitionLomuto(array, left, right);\n\n//     if (left < pivot - 1) {\n//         [_, animationsLeft] = quicksortLomuto(array, left, pivot - 1);\n//     }\n\n//     if (right > pivot) {\n//         [_, animationsRight] = quicksortLomuto(array, pivot - 1, right)\n//     }\n\n//     animationsQuickSort = [...animationsPartition, ...animationsRight, ...animationsLeft];\n\n//     return [array, animationsQuickSort];\n// }\n\n// function partitionLomuto(array, left, right) {\n//     // Lomuto algorithm always uses the last element, array[right], for the pivot.\n//     var animations = [];\n//     var pivot = right;\n//     var i = left;\n\n//     /*The logic under Lomuto is, we start from the leftmost element and keep track of index of smaller (or equal to) elements as j. While traversing, if we find a smaller element, we swap current element with arr[j]. Otherwise we ignore current element.*/\n//     for (var j = left; j < right; j++) {\n//         if (array[j] <= array[pivot]) {\n//             animations.push([\"swap\", i, j]);\n//             swap(array, i, j);\n//             i++\n//         }\n//     }\n//     animations.push([\"swap\", i, j]);\n//     swap(array, i, j);\n//     return [i, animations];\n// }\n\n\n// JavaScript implementation QuickSort\n// using Lomuto's partition Scheme\n \nfunction Swap(array, position1, position2)\n{\n    // Swaps elements in an array\n      \n    // Copy the first position's element\n    let temp = array[position1];\n      \n    // Assign to the second element\n    array[position1] = array[position2];\n      \n    // Assign to the first element\n    array[position2] = temp;\n}\n  \n/* This function takes last element as\npivot, places the pivot element at its\ncorrect position in sorted array, and\nplaces all smaller (smaller than pivot)\nto left of pivot and all greater elements\nto right of pivot */\nfunction partition(arr, low, high)\n{\n    let pivot = arr[high];\n      \n    // Index of smaller element\n    let i = (low - 1);\n  \n    for (let j = low; j <= high- 1; j++)\n    {\n        // If current element is smaller\n        // than or equal to pivot\n        if (arr[j] <= pivot)\n        {\n            i++; // increment index of\n                 // smaller element\n            Swap(arr, i, j);\n        }\n    }\n    Swap(arr, i + 1, high);\n    return (i + 1);\n}\n  \n/* The main function that\n   implements QuickSort\narr[] --> Array to be sorted,\nlow --> Starting index,\nhigh --> Ending index */\nfunction quicksortLomuto(arr, low, high)\n{\n    if (low < high)\n    {\n        /* pi is partitioning index,\n        arr[p] is now at right place */\n        let pi = partition(arr, low, high);\n  \n        // Separately sort elements before\n        // partition and after partition\n        quicksortLomuto(arr, low, pi - 1);\n        quicksortLomuto(arr, pi + 1, high);\n        return arr;\n    }\n}\n\nexport default quicksortLomuto;"]},"metadata":{},"sourceType":"module"}