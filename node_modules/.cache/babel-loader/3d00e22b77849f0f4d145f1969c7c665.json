{"ast":null,"code":"// First write the swap function, which is just a helper function to swap values of the array.\nfunction swap(array, i, j) {\n  var temp = array[i];\n  array[i] = array[j];\n  array[j] = temp;\n}\n\nfunction quicksortLomuto(array, left, right) {\n  var _;\n\n  var animationsQuickSort = [];\n  var animationsLeft = [];\n  var animationsRight = [];\n  var animationsPartition = [];\n  var pivot;\n  [pivot, animationsPartition] = partitionLomuto(array, left, right);\n\n  if (left < pivot - 1) {\n    [_, animationsLeft] = quicksortLomuto(array, left, pivot - 1);\n    [_, animationsRight] = quicksortLomuto(array, pivot + 1, right);\n  } // if (right > pivot) {\n  //     [_, animationsRight] = quicksortLomuto(array, pivot - 1, right);\n  // }\n\n\n  animationsQuickSort = [...animationsPartition, ...animationsRight, ...animationsLeft];\n  return [array, animationsQuickSort];\n}\n\nfunction partitionLomuto(array, left, right) {\n  // Lomuto algorithm always uses the last element, array[right], for the pivot.\n  var animations = [];\n  var pivot = right;\n  var i = left;\n  /*The logic under Lomuto is, we start from the leftmost element and keep track of index of smaller (or equal to) elements as j. While traversing, if we find a smaller element, we swap current element with arr[j]. Otherwise we ignore current element.*/\n\n  for (var j = left; j < right; j++) {\n    // if (array[j] === undefined || array[pivot] === undefined) {\n    //     break;\n    // }\n    if (array[j].props.value < array[pivot].props.value) {\n      animations.push([\"swap\", i, j]);\n      swap(array, i, j);\n      i++;\n    }\n  }\n\n  animations.push([\"swap\", i, pivot]);\n  swap(array, i, j);\n  return [i, animations];\n}\n\nexport default quicksortLomuto;","map":{"version":3,"sources":["/Users/andres/Desktop/personal_projects/learning-react/sorting-visualizer/src/sorting_algorithms/quickSortLomunto.js"],"names":["swap","array","i","j","temp","quicksortLomuto","left","right","_","animationsQuickSort","animationsLeft","animationsRight","animationsPartition","pivot","partitionLomuto","animations","props","value","push"],"mappings":"AACA;AACA,SAASA,IAAT,CAAcC,KAAd,EAAqBC,CAArB,EAAwBC,CAAxB,EAA2B;AACvB,MAAIC,IAAI,GAAGH,KAAK,CAACC,CAAD,CAAhB;AACAD,EAAAA,KAAK,CAACC,CAAD,CAAL,GAAWD,KAAK,CAACE,CAAD,CAAhB;AACAF,EAAAA,KAAK,CAACE,CAAD,CAAL,GAAWC,IAAX;AACH;;AAED,SAASC,eAAT,CAAyBJ,KAAzB,EAAgCK,IAAhC,EAAsCC,KAAtC,EAA6C;AACzC,MAAIC,CAAJ;;AACA,MAAIC,mBAAmB,GAAG,EAA1B;AACA,MAAIC,cAAc,GAAG,EAArB;AACA,MAAIC,eAAe,GAAG,EAAtB;AACA,MAAIC,mBAAmB,GAAG,EAA1B;AACA,MAAIC,KAAJ;AAEA,GAACA,KAAD,EAAQD,mBAAR,IAAgCE,eAAe,CAACb,KAAD,EAAQK,IAAR,EAAcC,KAAd,CAA/C;;AAEA,MAAID,IAAI,GAAGO,KAAK,GAAG,CAAnB,EAAsB;AAClB,KAACL,CAAD,EAAIE,cAAJ,IAAsBL,eAAe,CAACJ,KAAD,EAAQK,IAAR,EAAcO,KAAK,GAAG,CAAtB,CAArC;AACA,KAACL,CAAD,EAAIG,eAAJ,IAAuBN,eAAe,CAACJ,KAAD,EAAQY,KAAK,GAAG,CAAhB,EAAmBN,KAAnB,CAAtC;AACH,GAbwC,CAezC;AACA;AACA;;;AAEAE,EAAAA,mBAAmB,GAAG,CAAC,GAAGG,mBAAJ,EAAyB,GAAGD,eAA5B,EAA6C,GAAGD,cAAhD,CAAtB;AAEA,SAAO,CAACT,KAAD,EAAQQ,mBAAR,CAAP;AACH;;AAED,SAASK,eAAT,CAAyBb,KAAzB,EAAgCK,IAAhC,EAAsCC,KAAtC,EAA6C;AACzC;AACA,MAAIQ,UAAU,GAAG,EAAjB;AACA,MAAIF,KAAK,GAAGN,KAAZ;AACA,MAAIL,CAAC,GAAGI,IAAR;AAEA;;AACA,OAAK,IAAIH,CAAC,GAAGG,IAAb,EAAmBH,CAAC,GAAGI,KAAvB,EAA8BJ,CAAC,EAA/B,EAAmC;AAE/B;AACA;AACA;AAEA,QAAIF,KAAK,CAACE,CAAD,CAAL,CAASa,KAAT,CAAeC,KAAf,GAAuBhB,KAAK,CAACY,KAAD,CAAL,CAAaG,KAAb,CAAmBC,KAA9C,EAAqD;AACjDF,MAAAA,UAAU,CAACG,IAAX,CAAgB,CAAC,MAAD,EAAShB,CAAT,EAAYC,CAAZ,CAAhB;AACAH,MAAAA,IAAI,CAACC,KAAD,EAAQC,CAAR,EAAWC,CAAX,CAAJ;AACAD,MAAAA,CAAC;AACJ;AACJ;;AACDa,EAAAA,UAAU,CAACG,IAAX,CAAgB,CAAC,MAAD,EAAShB,CAAT,EAAYW,KAAZ,CAAhB;AACAb,EAAAA,IAAI,CAACC,KAAD,EAAQC,CAAR,EAAWC,CAAX,CAAJ;AACA,SAAO,CAACD,CAAD,EAAIa,UAAJ,CAAP;AACH;;AAED,eAAeV,eAAf","sourcesContent":["\n// First write the swap function, which is just a helper function to swap values of the array.\nfunction swap(array, i, j) {\n    var temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n}\n\nfunction quicksortLomuto(array, left, right) {\n    var _;\n    var animationsQuickSort = []\n    var animationsLeft = [];\n    var animationsRight = [];\n    var animationsPartition = [];\n    var pivot;\n\n    [pivot, animationsPartition]  = partitionLomuto(array, left, right);\n\n    if (left < pivot - 1) {\n        [_, animationsLeft] = quicksortLomuto(array, left, pivot - 1);\n        [_, animationsRight] = quicksortLomuto(array, pivot + 1, right);\n    }\n\n    // if (right > pivot) {\n    //     [_, animationsRight] = quicksortLomuto(array, pivot - 1, right);\n    // }\n\n    animationsQuickSort = [...animationsPartition, ...animationsRight, ...animationsLeft];\n\n    return [array, animationsQuickSort];\n}\n\nfunction partitionLomuto(array, left, right) {\n    // Lomuto algorithm always uses the last element, array[right], for the pivot.\n    var animations = [];\n    var pivot = right;\n    var i = left;\n\n    /*The logic under Lomuto is, we start from the leftmost element and keep track of index of smaller (or equal to) elements as j. While traversing, if we find a smaller element, we swap current element with arr[j]. Otherwise we ignore current element.*/\n    for (var j = left; j < right; j++) {\n\n        // if (array[j] === undefined || array[pivot] === undefined) {\n        //     break;\n        // }\n\n        if (array[j].props.value < array[pivot].props.value) {\n            animations.push([\"swap\", i, j]);\n            swap(array, i, j);\n            i++;\n        }\n    }\n    animations.push([\"swap\", i, pivot]);\n    swap(array, i, j);\n    return [i, animations];\n}\n\nexport default quicksortLomuto;"]},"metadata":{},"sourceType":"module"}